// Copyright (C) 2020-2025  The Blockhouse Technology Limited (TBTL).
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or (at your
// option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
// License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

//! This module defines the data model described in the section "9.1.3 mdoc authentication" of the
//! [ISO/IEC 18013-5:2021][1] standard, but modified for [OpenID for Verifiable Presentations][2].
//!
//! [1]: <https://www.iso.org/standard/69084.html>
//! [2]: <https://openid.net/specs/openid-4-verifiable-presentations-1_0.html>

use bh_jws_utils::{SignatureVerifier, SigningAlgorithm};
use bherror::traits::{ErrorContext as _, ForeignBoxed as _, ForeignError as _};
use ciborium::{into_writer, Value};
use coset::{CoseMac0, CoseSign1, CoseSign1Builder, RegisteredLabelWithPrivate};
use serde::{ser::SerializeSeq as _, Deserialize, Serialize};

use super::response::DeviceNameSpacesBytes;
use crate::{
    models::{data_retrieval::common::DocType, Bytes, BytesCbor},
    utils::{
        coset::{coset_alg_to_jws_alg, deserialize_coset, jws_alg_to_coset_alg, serialize_coset},
        digest::sha256,
    },
    DeviceKey, MdocError, Result,
};

/// A string contained in the payload for the device signature, as specified in
/// the `Section 9.1.3.4` of the [ISO/IEC 18013-5:2021][1].
///
/// [1]: <https://www.iso.org/standard/69084.html>
const DEVICE_AUTHENTICATION_IDENTIFIER: &str = "DeviceAuthentication";

/// The signature or MAC generated by the `mDoc` device.
///
/// The underlying structure is either the `COSE_Sign1` or the `COSE_Mac0`,
/// depending on whether the signature or MAC is used, respectively.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum DeviceAuth {
    /// `COSE_Sign1` variant.
    DeviceSignature(DeviceSignature),
    /// `COSE_Mac0` variant.
    DeviceMac(DeviceMac),
}

impl DeviceAuth {
    /// Creates a new [`DeviceAuth`] with the [`DeviceSignature`].
    pub(crate) fn new_signature(
        device_authentication: DeviceAuthentication,
        signer: &impl bh_jws_utils::Signer,
    ) -> Result<Self> {
        Ok(Self::DeviceSignature(DeviceSignature::new(
            device_authentication,
            signer,
        )?))
    }

    /// Verifies the underlying signature or MAC.
    ///
    /// The payload itself is detached, i.e. it is not contained in the
    /// underlying structure, and needs to be provided as an argument.
    ///
    /// **Note**: currently, only the signature is supported. Verifying the MAC
    /// results in the [DeviceMac][MdocError::DeviceMac] error.
    pub(crate) fn verify_signature<'a>(
        &self,
        device_authentication: DeviceAuthentication,
        get_signature_verifier: impl Fn(SigningAlgorithm) -> Option<&'a dyn SignatureVerifier>,
        device_key: &DeviceKey,
    ) -> Result<()> {
        match self {
            Self::DeviceSignature(device_signature) => device_signature.verify_signature(
                device_authentication,
                get_signature_verifier,
                device_key,
            ),
            Self::DeviceMac(_device_mac) => Err(bherror::Error::root(MdocError::DeviceMac)),
        }
    }

    #[cfg(test)]
    pub(crate) fn device_signature_inner_mut(&mut self) -> &mut CoseSign1 {
        match self {
            DeviceAuth::DeviceSignature(signature) => &mut signature.0,
            _ => unimplemented!(),
        }
    }
}

/// [`DeviceSignature`] as defined in the section `9.1.3.4` of the [ISO/IEC 18013-5:2021][1]
/// standard.
///
/// [1]: <https://www.iso.org/standard/69084.html>
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeviceSignature(
    #[serde(
        serialize_with = "serialize_coset",
        deserialize_with = "deserialize_coset"
    )]
    pub(crate) CoseSign1,
);

impl From<CoseSign1> for DeviceSignature {
    fn from(value: coset::CoseSign1) -> Self {
        Self(value)
    }
}

impl DeviceSignature {
    fn new(
        device_authentication: DeviceAuthentication,
        signer: &impl bh_jws_utils::Signer,
    ) -> Result<Self> {
        let protected = coset::Header {
            alg: Some(RegisteredLabelWithPrivate::Assigned(jws_alg_to_coset_alg(
                &signer.algorithm(),
            ))),
            ..Default::default()
        };

        let payload = device_signature_and_mac_payload(device_authentication)?;

        let cose_sign1 = CoseSign1Builder::new()
            .protected(protected)
            .try_create_detached_signature(&payload, &[], |data| signer.sign(data))
            .foreign_boxed_err(|| MdocError::Signing)?
            .build();

        Ok(Self(cose_sign1))
    }

    fn verify_signature<'a>(
        &self,
        device_authentication: DeviceAuthentication,
        get_signature_verifier: impl Fn(SigningAlgorithm) -> Option<&'a dyn SignatureVerifier>,
        device_key: &DeviceKey,
    ) -> Result<()> {
        let alg = self
            .signing_algorithm()
            .ok_or_else(|| bherror::Error::root(MdocError::MissingSigningAlgorithm))
            .ctx(|| "device authentication")?;

        let jwk = device_key.as_jwk()?;

        let signature_verifier = get_signature_verifier(alg)
            .ok_or_else(|| bherror::Error::root(MdocError::MissingSignatureVerifier(alg)))?;

        let payload = device_signature_and_mac_payload(device_authentication)?;

        self.0
            .verify_detached_signature(&payload, &[], |sig, data| {
                let verified = signature_verifier
                    .verify(data, sig, &jwk)
                    .foreign_boxed_err(|| MdocError::InvalidSignature)
                    .ctx(|| "error while verifying signature")?;

                if !verified {
                    return Err(bherror::Error::root(MdocError::InvalidSignature)
                        .ctx("the signature is not valid"));
                };

                Ok(())
            })
    }

    /// Return the `alg` element from the protected header of the underlying
    /// `COSE_Sign1` structure.
    pub fn signing_algorithm(&self) -> Option<SigningAlgorithm> {
        let alg = self.0.protected.header.alg.as_ref()?;

        let RegisteredLabelWithPrivate::Assigned(alg) = alg else {
            return None;
        };

        coset_alg_to_jws_alg(alg)
    }
}

/// [`DeviceMac`] as defined in the section `9.1.3.4` of the [ISO/IEC 18013-5:2021][1] standard.
///
/// [1]: <https://www.iso.org/standard/69084.html>
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeviceMac(
    #[serde(
        serialize_with = "serialize_coset",
        deserialize_with = "deserialize_coset"
    )]
    pub(crate) CoseMac0,
);

/// [`DeviceAuthenticationBytes`] as defined in the section `9.1.3.4` of the [ISO/IEC
/// 18013-5:2021][1] standard.
///
/// [1]: <https://www.iso.org/standard/69084.html>
#[derive(Debug, Serialize)]
pub struct DeviceAuthenticationBytes<'a>(BytesCbor<DeviceAuthentication<'a>>);

impl<'a> From<DeviceAuthentication<'a>> for DeviceAuthenticationBytes<'a> {
    fn from(value: DeviceAuthentication<'a>) -> Self {
        Self(value.into())
    }
}

/// The payload for the device signature.
///
/// The actual payload is constructed by converting this to
/// [`DeviceAuthenticationBytes`] and serializing it as CBOR.
///
/// It borrows all the underlying fields to generate a serialized payload, and
/// those fields are `client_id`, `response_uri`, `mdoc_generated_nonce`,
/// `nonce`, `doc_type` and `name_spaces`.
///
/// The payload is constructed as specified in the `Section 9.1.3.4` of the
/// [ISO/IEC 18013-5:2021][1] and the `Section B.4.4` of the
/// [ISO/IEC TS 18013-7:2024][2].
///
/// [1]: <https://www.iso.org/standard/69084.html>
/// [2]: <https://www.iso.org/standard/82772.html>
#[derive(Debug)]
pub struct DeviceAuthentication<'a> {
    session_transcript: SessionTranscript<'a>,
    doc_type: &'a DocType,
    name_spaces: &'a DeviceNameSpacesBytes,
}

impl<'a> DeviceAuthentication<'a> {
    /// Create a new [`DeviceAuthentication`] payload for the device signature.
    pub fn new(
        client_id: &'a str,
        response_uri: &'a str,
        nonce: &'a str,
        mdoc_generated_nonce: &'a str,
        doc_type: &'a DocType,
        name_spaces: &'a DeviceNameSpacesBytes,
    ) -> Self {
        Self {
            session_transcript: SessionTranscript {
                handover: OID4VPHandover {
                    client_id_hash: ClientIdHash {
                        client_id_to_hash: ClientIdToHash {
                            client_id,
                            mdoc_generated_nonce,
                        },
                    },
                    response_uri_hash: ResponseUriHash {
                        response_uri_to_hash: ResponseUriToHash {
                            response_uri,
                            mdoc_generated_nonce,
                        },
                    },
                    nonce,
                },
            },
            doc_type,
            name_spaces,
        }
    }
}

impl Serialize for DeviceAuthentication<'_> {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(4))?;

        seq.serialize_element(DEVICE_AUTHENTICATION_IDENTIFIER)?;
        seq.serialize_element(&self.session_transcript)?;
        seq.serialize_element(self.doc_type)?;
        seq.serialize_element(self.name_spaces)?;

        seq.end()
    }
}

/// [`SessionTranscript`] as defined in the section `9.1.5.1` of the [ISO/IEC 18013-5:2021][1]
/// standard, but modified for [OpenID for Verifiable Presentations][2].
///
/// [1]: <https://www.iso.org/standard/69084.html>
/// [2]: <https://openid.net/specs/openid-4-verifiable-presentations-1_0.html#appendix-B.3.5>
#[derive(Debug)]
pub struct SessionTranscript<'a> {
    handover: OID4VPHandover<'a>,
}

impl Serialize for SessionTranscript<'_> {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(3))?;

        seq.serialize_element(&Value::Null)?;
        seq.serialize_element(&Value::Null)?;
        seq.serialize_element(&self.handover)?;

        seq.end()
    }
}

/// [`OID4VPHandover`] as defined in [OpenID for Verifiable Presentations][1].
///
/// [1]: <https://openid.net/specs/openid-4-verifiable-presentations-1_0.html#appendix-B.3.5>
#[derive(Debug)]
pub struct OID4VPHandover<'a> {
    client_id_hash: ClientIdHash<'a>,
    response_uri_hash: ResponseUriHash<'a>,
    nonce: &'a str,
}

impl Serialize for OID4VPHandover<'_> {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(3))?;

        seq.serialize_element(&self.client_id_hash)?;
        seq.serialize_element(&self.response_uri_hash)?;
        seq.serialize_element(self.nonce)?;

        seq.end()
    }
}

/// SHA-256 hash of the `client_id`.
#[derive(Debug)]
pub struct ClientIdHash<'a> {
    client_id_to_hash: ClientIdToHash<'a>,
}

impl Serialize for ClientIdHash<'_> {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut payload = Vec::new();
        into_writer(&self.client_id_to_hash, &mut payload).map_err(serde::ser::Error::custom)?;

        let bytes: Bytes = sha256(payload).to_vec().into();

        bytes.serialize(serializer)
    }
}

/// SHA-256 hash of the `response_uri`.
#[derive(Debug)]
pub struct ResponseUriHash<'a> {
    response_uri_to_hash: ResponseUriToHash<'a>,
}

impl Serialize for ResponseUriHash<'_> {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut payload = Vec::new();
        into_writer(&self.response_uri_to_hash, &mut payload).map_err(serde::ser::Error::custom)?;

        let bytes: Bytes = sha256(payload).to_vec().into();

        bytes.serialize(serializer)
    }
}

/// Wrapper type for hashing `client_id` and `nonce`.
#[derive(Debug)]
pub struct ClientIdToHash<'a> {
    client_id: &'a str,
    mdoc_generated_nonce: &'a str,
}

impl Serialize for ClientIdToHash<'_> {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(2))?;

        seq.serialize_element(self.client_id)?;
        seq.serialize_element(self.mdoc_generated_nonce)?;

        seq.end()
    }
}

/// Wrapper type for hashing `response_uri` and `nonce`.
#[derive(Debug)]
pub struct ResponseUriToHash<'a> {
    response_uri: &'a str,
    mdoc_generated_nonce: &'a str,
}

impl Serialize for ResponseUriToHash<'_> {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(2))?;

        seq.serialize_element(self.response_uri)?;
        seq.serialize_element(self.mdoc_generated_nonce)?;

        seq.end()
    }
}

/// Constructs the payload for the [`DeviceSignature`] or the [`DeviceMac`].
fn device_signature_and_mac_payload(
    device_authentication: DeviceAuthentication,
) -> Result<Vec<u8>> {
    let mut payload = Vec::new();
    into_writer(
        &DeviceAuthenticationBytes::from(device_authentication),
        &mut payload,
    )
    .foreign_err(|| MdocError::DeviceAuthentication)?;

    Ok(payload)
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Example taken from the `B.6.9` of the [ISO/IEC TS 18013-7:2024][1].
    ///
    /// [1]: <https://www.iso.org/standard/82772.html>
    #[test]
    fn test_oid4vp_handover_serialization() {
        let client_id = "example.com";
        let response_uri = "https://example.com/12345/response";
        let mdoc_generated_nonce = "1234567890abcdefgh";
        let nonce = "abcdefgh1234567890";

        let handover = OID4VPHandover {
            client_id_hash: ClientIdHash {
                client_id_to_hash: ClientIdToHash {
                    client_id,
                    mdoc_generated_nonce,
                },
            },
            response_uri_hash: ResponseUriHash {
                response_uri_to_hash: ResponseUriToHash {
                    response_uri,
                    mdoc_generated_nonce,
                },
            },
            nonce,
        };

        let expected_hex = "835820DA25C527E5FB75BC2DD31267C02237C4462BA0C1BF370\
71F692E7DD93B10AD0B5820F6ED8E3220D3C59A5F17EB45F48AB70AEECF9EE21744B1014982350B\
D96AC0C572616263646566676831323334353637383930";

        let mut encoded = Vec::new();
        into_writer(&handover, &mut encoded).unwrap();

        let encoded_hex = hex::encode(encoded).to_uppercase();

        assert_eq!(expected_hex, encoded_hex);
    }

    /// Example taken from the `B.6.9` of the [ISO/IEC TS 18013-7:2024][1].
    ///
    /// [1]: <https://www.iso.org/standard/82772.html>
    #[test]
    fn test_session_transcript_serialization() {
        let client_id = "example.com";
        let response_uri = "https://example.com/12345/response";
        let mdoc_generated_nonce = "1234567890abcdefgh";
        let nonce = "abcdefgh1234567890";

        let session_transcript = SessionTranscript {
            handover: OID4VPHandover {
                client_id_hash: ClientIdHash {
                    client_id_to_hash: ClientIdToHash {
                        client_id,
                        mdoc_generated_nonce,
                    },
                },
                response_uri_hash: ResponseUriHash {
                    response_uri_to_hash: ResponseUriToHash {
                        response_uri,
                        mdoc_generated_nonce,
                    },
                },
                nonce,
            },
        };

        let expected_hex = "83F6F6835820DA25C527E5FB75BC2DD31267C02237C4462BA0C\
1BF37071F692E7DD93B10AD0B5820F6ED8E3220D3C59A5F17EB45F48AB70AEECF9EE21744B10149\
82350BD96AC0C572616263646566676831323334353637383930";

        let mut encoded = Vec::new();
        into_writer(&session_transcript, &mut encoded).unwrap();

        let encoded_hex = hex::encode(encoded).to_uppercase();

        assert_eq!(expected_hex, encoded_hex);
    }
}
